Description on the approach:

To create a parallel solution, I have broken down the averaging of the array elements into rows. Each thread is assigned a row and will then loop through each element in that row to calculate the new value (ignoring border values). For example, if the solver is utilising 4 threads, 4 threads will be created to calculate values for row x, x+1, x+2 and x+3. Now the solver can calculate the averages for multiple rows in parallel. When the threads are finished, they are joined then the process repeats through the rest of the array. When nearing the end of the array,we may have more threads available than the number of rows left. A counter is used to ensure only the required amount of threads are created. The precision check is also done in parallel. If all the elements in a row have reached the desired precision, a completed counter is updated. This choice was taken to maximise the amount of work done in parallel that wouldnâ€™t cause memory issues.

In order to avoid race conditions, two separate arrays are used, an array for reading from and an array for writing to. When the threads are created, a pointer to the read array is passed to the thread function, allowing all threads to read the same array. A pointer to a write array is also passed to each thread. Each thread will only ever edit the write array. By doing this, there is no concern over whether a thread is accessing the original value of another row or the new value another thread has calculated. Once all the threads are finished, the read array is updated with the new values in the write array.